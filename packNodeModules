#!/usr/bin/env node
const {exec} = require('child_process');
const fs = require('fs');
const path = require('path');
const yargs = require('yargs/yargs');
const {hideBin} = require('yargs/helpers');

const getRecursiveDependencies = (list) => {
    const mainDependencies = Object.keys(list);
    const result = mainDependencies.map(dep => `${dep}@${list[dep].version}`);
    mainDependencies.forEach(dep => {
        if (list[dep].dependencies) {
            result.push(...getRecursiveDependencies(list[dep].dependencies));
        }
    });
    return result;
};


const getPackageListFromLock = (packageLock, filter) => {
    const dependencies = getRecursiveDependencies(JSON.parse(packageLock).dependencies);
    const unique = [...new Set(dependencies)];
    if (!filter) return unique;
    const regex = new RegExp(filter, 'g');
    return unique.filter(dependence=>!dependence.match(regex));
};


async function packageDependencies(lisOfDependencies, target = 'tars') {
    const installed = [];
    exec(`mkdir ${target}`);
    try{
        const installedPackages = lisOfDependencies.map(dependence => asyncExec(`npm pack ${dependence} --pack-destination ./${target}`));
        const output = {
            fulfilled:[],
            rejected:[]
        };
        (await Promise.allSettled(installedPackages))
            .forEach((package, index)=> {
                output[package.status].push(package.value.slice(0, -1));
                installed.push(lisOfDependencies[index]);
            });
        console.log('packed the following packages:\n',output.fulfilled);
        if(output.rejected.length){
            console.log('fail to pack the following packages:\n',output.rejected);
        }

    }catch(e){
        console.error(e);
    }
    return installed;
}

async function asyncExec(command) {
    return new Promise((resolve, reject) => {
        exec(command, (err, stdout) => {
            if (err) {
                return reject(err);
            }
            resolve(stdout);
        });
    });
}

async function writeOutputFile(packages, target = 'tars'){
    try {
        fs.writeFileSync(`./${target}/output.txt`, JSON.stringify(packages));
    } catch (err) {
        console.error(err)
    }
}

function readExistingFile(target = 'tars'){
    try {
        console.log(process.cwd());
        console.log(__dirname);
        return fs.readFileSync(path.resolve(__dirname, `${target}`));
    } catch (err) {
        console.error(err);
        return [];
    }
}

async function main(argv) {
    const path = argv.path ? `${argv.path}/` : ''
    const lockFlag = argv['use-installed'] ? '' : '--package-lock-only';
    const packageLock = await asyncExec(`npm ls ${path} --all ${lockFlag} --json`);
    const excludeList = argv.existing_list ? readExistingFile(argv.existing_list) : [];
    const packageList = getPackageListFromLock(packageLock, argv.filter);
    const installedPackages = await packageDependencies(packageList, argv.target);
    writeOutputFile(installedPackages, argv.target);
    console.log(excludeList);
}

yargs(hideBin(process.argv))
    .command('$0', 'packNodeModules all dependencies for project', (yargs) => {
        return yargs
    }, main)
    .option('target', {
        alias: 't',
        type: 'string',
        description: 'target folder for tars'
    }).option('existing_list', {
        alias: 'e',
        type: 'string',
        description: 'path to file containing a list of existing packages that don\'t need to be packaged. Output file will include these files'
    }).option('use-installed', {
        alias: 'i',
        type: 'boolean',
        description: 'will use installed packages from node modules instead of package-lock.json file.'
    }).option('filter', {
    alias: 'f',
    type: 'string',
    description: 'use regex to filter out unwanted packages. for example: \npackNodeModules -f ^@mock\\/\n will remove packages starting with @mock/'
})
    .parse()
